<!DOCTYPE html>
<html lang="ja">
  <head>
    <meta charset="utf-8" />
    <title>X68000</title>
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <link rel="icon" href="nes.png" type="image/png">
    <style>
       :root {
        color-scheme: light dark;
      }
      @font-face {
  font-family: "Renner";
  src: url("./Renner.ttf") format("truetype");
  font-display: swap;
 
}
      body {
        background:rgb(0, 0, 0);
       font-family: "Renner", sans-serif;
        margin: 0;
        padding:0;
      }
h1{
font-weight:300;
font-size:25px;
}
      header {
        display: flex;
        gap: 12px;
        align-items: center;
        margin-bottom: 12px;
      }
      canvas{
        
        height: 100%;              /* コンテナ幅に合わせる */
      aspect-ratio: 256 / 240;  /* 内部解像度の比率を維持 */
        image-rendering: pixelated;
        border: 1px solid #000000;
        background: #000;
      }
      .row {
        padding-top:0px;
height:83vh;
justify-content: center; 
        display: flex;
        gap: 12px;
        align-items: center;
      }
      .mono {
       font-size:20px; 
      }
      small {
        opacity: 0.7;
      }
      
button{
font-family: "Renner", sans-serif;
padding:10px;
background:rgb(0, 0, 0);
color:rgb(255, 255, 255);
border:1px solid rgb(255, 255, 255);
}
.file-input {
  display: none; /* 本体は隠す */
}

.file-label {
  display: inline-block;
  padding: 10px 16px;
  background: #000000;
  color: white;
    border:1px solid white;
  border-radius: 0px;
  cursor: pointer;
  font-size: 14px;
  transition: background 0.2s;
}



    </style>
  </head>
  <body>
   
    <header>
<h1>X68000</h1>
      
<label class="file-label">
  Select
  <input id="rom" type="file" class="file-input">
</label>
<span id="file-name"></span>

      
      <button id="fullscreenBtn">Fullscreen</button>

      <button id="start">Start</button>
      <div class="mono" id="status">No ROM</div>
      <label class="file-label">
    IPL ROM
    <input id="iplrom" type="file" class="file-input">
  </label>
  <span id="ipl-name" class="file-status"></span>

  <label class="file-label">
    CG ROM
    <input id="cgrom" type="file" class="file-input">
  </label>
  <span id="cg-name" class="file-status"></span>
  
      <div><span class="mono">CPU PC:</span> <span id="pc" class="mono">0x0000</span></div>
    </header>
    <div class="row">
      <canvas id="screen" width="256" height="240"></canvas>
      <div style="display:none">
        <div><b>FPS:</b> <span id="fps">0</span></div>
        <div><b>CPU PC:</b> <span id="pc" class="mono">0x0000</span></div>
        <div><b>Cycles:</b> <span id="cyc" class="mono">0</span></div>
        <div><b>VRAM V:</b><span id="pcp" class="mono">0x0000</span></div>
        <div><b>VRAM T:</b><span id="ppx" class="mono">0x0000</span></div>
        <div><b>CPU S:</b><span id="ram" class="mono">0x0000</span></div>
        <div><b>CPU P:</b><span id="mapper" class="mono">0x0000</span></div>

        
      </div>
    </div>

    

    <script type="module">
function drawTestPattern(x68k) {
  const mem = x68k.memory;

  // 全プレーン初期化
  for (let p = 0; p < 4; p++) {
    mem.gvr[p].fill(0);
  }

  // 512x512 / 8px単位で縦縞
  for (let y = 0; y < 512; y++) {
    for (let bx = 0; bx < 512 / 8; bx++) {
      const addr = y * (512 / 8) + bx;

      // 0〜15を繰り返す
      const col = (bx >> 1) & 0xF;

      for (let p = 0; p < 4; p++) {
        mem.gvr[p][addr] = ((col >> p) & 1) ? 0xFF : 0x00;
      }
    }
  }
}

/* =========================
   X68000 Core
========================= */
class X68000 {
  constructor(canvas) {
    this.cpu = new MC68000(this);
    this.memory = new MemoryMap();
    this.video = new VideoSubsystem(canvas,this);
    this.sound = new SoundSubsystem();
    this.input = new InputSubsystem();
this.crtc = new CRTC();

    this.running = false;
    this.lastTime = 0;
  }

  reset() {
    this.memory.reset();
    this.cpu.reset();
    this.video.reset();
    this.sound.reset();
    this.running = false;
  }

  loadROM(buffer) {
    this.memory.loadROM(buffer);
  }

  start() {
    this.running = true;
    requestAnimationFrame(this.loop.bind(this));
  }

  loop(time) {
    if (!this.running) return;

    const delta = time - this.lastTime;
    this.lastTime = time;

    // 1フレーム分実行（仮）
    this.stepFrame();

    this.video.render();

    requestAnimationFrame(this.loop.bind(this));
  }

  stepFrame() {
    const CYCLES_PER_FRAME = 100000; // 仮

    let cycles = 0;
    while (cycles < CYCLES_PER_FRAME) {
      cycles += this.cpu.step();
    }
  }
}

/* =========================
   MC68000 CPU (Stub)
========================= */
class MC68000 {
  constructor(system) {
    this.system = system;
    this.d = new Uint32Array(8);  // データレジスタ D0-D7
    this.a = new Uint32Array(8);  // アドレスレジスタ A0-A7
    this.pc = 0;                  // プログラムカウンタ
    this.sr = 0x2700;             // ステータスレジスタ
    this.cycles = 0;
  }

  reset() {
    // 初期スタックポインタとPCを取得
    const mem = this.system.memory;
    this.a[7] = (mem.read8(0) << 24) | (mem.read8(1) << 16) | 
                (mem.read8(2) << 8) | mem.read8(3);
    this.pc = (mem.read8(4) << 24) | (mem.read8(5) << 16) | 
              (mem.read8(6) << 8) | mem.read8(7);
    
    this.d.fill(0);
    this.a.fill(0);
    this.a[7] = this.a[7] || 0x100000;
    this.sr = 0x2700;
    this.cycles = 0;
  }
readWord() {
    const val = (this.system.memory.read8(this.pc) << 8) | 
                 this.system.memory.read8(this.pc + 1);
    this.pc += 2;
    return val;
  }

  readLong() {
    const high = this.readWord();
    const low = this.readWord();
    return (high << 16) | low;
  }
  step() {
    const opcode = this.readWord();
    
    // 命令デコード
    const decoded = this.decode(opcode);
    if (decoded) {
      decoded();
    }
    
    return 4; // 仮のサイクル数
  }

  decode(opcode) {
    // MOVE命令 (00xx, 01xx, 10xx, 11xx)
    if ((opcode & 0xC000) !== 0) {
      const size = (opcode >> 12) & 3;
      if (size === 1 || size === 3 || size === 2) {
        return () => this.execMove(opcode, size);
      }
    }

    // NOP (0x4E71)
    if (opcode === 0x4E71) {
      return () => {};
    }

    // RTS (0x4E75)
    if (opcode === 0x4E75) {
      return () => this.execRTS();
    }

    // JSR (0x4E8x, 0x4EAx, 0x4EBx)
    if ((opcode & 0xFFC0) === 0x4E80) {
      return () => this.execJSR(opcode);
    }

    // MOVEQ (0x7xxx)
    if ((opcode & 0xF100) === 0x7000) {
      return () => this.execMOVEQ(opcode);
    }

    // ADD/SUB (0xDxxx / 0x9xxx)
    if ((opcode & 0xF000) === 0xD000) {
      return () => this.execADD(opcode);
    }
    if ((opcode & 0xF000) === 0x9000) {
      return () => this.execSUB(opcode);
    }

    // CMP (0xBxxx)
    if ((opcode & 0xF000) === 0xB000) {
      return () => this.execCMP(opcode);
    }

    // Bcc (0x6xxx)
    if ((opcode & 0xF000) === 0x6000) {
      return () => this.execBcc(opcode);
    }

    // 未実装命令
    //console.warn(`Unknown opcode: 0x${opcode.toString(16).padStart(4, '0')} at PC: 0x${(this.pc-2).toString(16)}`);
    return () => {};
  }

  // MOVEQ - クイックムーブ
  execMOVEQ(opcode) {
    const reg = (opcode >> 9) & 7;
    let data = opcode & 0xFF;
    // 符号拡張
    if (data & 0x80) data |= 0xFFFFFF00;
    this.d[reg] = data >>> 0;
    this.updateFlags(data, 4);
  }

  // MOVE命令
  execMove(opcode, sizeCode) {
    const size = sizeCode === 1 ? 1 : sizeCode === 3 ? 2 : 4;
    const dstReg = (opcode >> 9) & 7;
    const dstMode = (opcode >> 6) & 7;
    const srcMode = (opcode >> 3) & 7;
    const srcReg = opcode & 7;

    const src = this.getEA(srcMode, srcReg, size);
    this.setEA(dstMode, dstReg, size, src);
    this.updateFlags(src, size);
  }

  // ADD命令
  execADD(opcode) {
    const reg = (opcode >> 9) & 7;
    const mode = (opcode >> 3) & 7;
    const ereg = opcode & 7;
    
    const src = this.getEA(mode, ereg, 4);
    const dst = this.d[reg];
    const result = (dst + src) >>> 0;
    
    this.d[reg] = result;
    this.updateFlags(result, 4);
  }

  // SUB命令
  execSUB(opcode) {
    const reg = (opcode >> 9) & 7;
    const mode = (opcode >> 3) & 7;
    const ereg = opcode & 7;
    
    const src = this.getEA(mode, ereg, 4);
    const dst = this.d[reg];
    const result = (dst - src) >>> 0;
    
    this.d[reg] = result;
    this.updateFlags(result, 4);
  }

  // CMP命令
  execCMP(opcode) {
    const reg = (opcode >> 9) & 7;
    const mode = (opcode >> 3) & 7;
    const ereg = opcode & 7;
    
    const src = this.getEA(mode, ereg, 4);
    const dst = this.d[reg];
    const result = (dst - src) >>> 0;
    
    this.updateFlags(result, 4);
  }

  // 分岐命令
  execBcc(opcode) {
    const cond = (opcode >> 8) & 0xF;
    let disp = opcode & 0xFF;
    
    if (disp === 0) {
      disp = this.readWord();
      if (disp & 0x8000) disp |= 0xFFFF0000;
    } else if (disp & 0x80) {
      disp |= 0xFFFFFF00;
    }

    if (this.testCondition(cond)) {
      this.pc = (this.pc + disp) >>> 0;
    }
  }

  // JSR - サブルーチンジャンプ
  execJSR(opcode) {
    const mode = (opcode >> 3) & 7;
    const reg = opcode & 7;
    
    const addr = this.getEA(mode, reg, 4);
    this.push32(this.pc);
    this.pc = addr;
  }

  // RTS - リターン
  execRTS() {
    this.pc = this.pop32();
  }

  // 実効アドレス取得
  getEA(mode, reg, size) {
    switch(mode) {
      case 0: // Dn
        return this.d[reg] & this.mask(size);
      case 1: // An
        return this.a[reg] & this.mask(size);
      case 7:
        if (reg === 4) { // immediate
          return size === 4 ? this.readLong() : this.readWord();
        }
        break;
    }
    return 0;
  }

  setEA(mode, reg, size, value) {
    switch(mode) {
      case 0: // Dn
        this.d[reg] = value & this.mask(size);
        break;
      case 1: // An
        this.a[reg] = value & this.mask(size);
        break;
    }
  }

  mask(size) {
    return size === 1 ? 0xFF : size === 2 ? 0xFFFF : 0xFFFFFFFF;
  }

  // フラグ更新
  updateFlags(result, size) {
    const mask = this.mask(size);
    result &= mask;
    
    this.sr &= 0xFFF0; // N,Z,V,C をクリア
    
    if (result === 0) this.sr |= 0x04; // Z
    if (size === 4 && (result & 0x80000000)) this.sr |= 0x08; // N
    if (size === 2 && (result & 0x8000)) this.sr |= 0x08;
    if (size === 1 && (result & 0x80)) this.sr |= 0x08;
  }

  testCondition(cond) {
    const z = (this.sr & 0x04) !== 0;
    const n = (this.sr & 0x08) !== 0;
    const c = (this.sr & 0x01) !== 0;
    const v = (this.sr & 0x02) !== 0;

    switch(cond) {
      case 0x0: return true;          // BRA
      case 0x1: return false;         // BSR
      case 0x4: return !c;            // BCC
      case 0x5: return c;             // BCS
      case 0x6: return !z;            // BNE
      case 0x7: return z;             // BEQ
      default: return false;
    }
  }

  push32(value) {
    this.a[7] -= 4;
    const addr = this.a[7];
    this.system.memory.write8(addr, (value >> 24) & 0xFF);
    this.system.memory.write8(addr + 1, (value >> 16) & 0xFF);
    this.system.memory.write8(addr + 2, (value >> 8) & 0xFF);
    this.system.memory.write8(addr + 3, value & 0xFF);
  }

  pop32() {
    const addr = this.a[7];
    const value = (this.system.memory.read8(addr) << 24) |
                  (this.system.memory.read8(addr + 1) << 16) |
                  (this.system.memory.read8(addr + 2) << 8) |
                  this.system.memory.read8(addr + 3);
    this.a[7] += 4;
    return value >>> 0;
  }
}

/* =========================
   Memory Map
========================= */
class MemoryMap {
  constructor() {
    this.ram = new Uint8Array(0x200000); // 2MB RAM
    this.rom = null;
    this.iplrom = null;                       // IPL ROM
    this.cgrom = null;  
    this.gvr = [
      new Uint8Array(0x20000), // Plane0
      new Uint8Array(0x20000), // Plane1
      new Uint8Array(0x20000), // Plane2
      new Uint8Array(0x20000)  // Plane3
    ];

    this.tram = new Uint16Array(0x10000); // Text VRAM
    this.palette = new Uint16Array(256); // 12bit RGB
  }
getFontBitmap(charCode, row) {
  if (!this.cgrom) return 0;

  const FONT8X8_BASE = 0x00000;
  return this.cgrom[
    FONT8X8_BASE + (charCode * 8) + (7 - row)
  ] || 0;
}



  reset() {
    this.ram.fill(0);
  }

  loadROM(buffer) {
    this.rom = new Uint8Array(buffer);
  }
loadIPLROM(buffer) {
    this.iplrom = new Uint8Array(buffer);
    console.log(`IPL ROM loaded: ${this.iplrom.length} bytes`);
  }

  loadCGROM(buffer) {
    this.cgrom = new Uint8Array(buffer);
    console.log(`CG ROM loaded: ${this.cgrom.length} bytes`);
  }

  read8(addr) {
    addr &= 0xFFFFFF; // 24bitアドレス
if (addr >= 0xC00000 && addr < 0xE00000) {
      const offset = addr - 0xC00000;
      const plane = (offset >> 17) & 3;
      return this.gvr[plane][offset & 0x1FFFF];
    }
    // IPL ROM: 0x000000-0x0BFFFF (768KB) または 0x0FFFFF (1MB)
    if (addr < 0x100000 && this.iplrom && addr < this.iplrom.length) {
      return this.iplrom[addr];
    }
    
    // RAM: 0x000000-0x1FFFFF (メインRAM)
    // ※実際はIPL ROMとRAMは排他的だが、簡易実装
    if (addr < 0x200000) {
      return this.ram[addr];
    }

    // CG ROM: 0xF00000-0xFBFFFF (768KB)
    if (addr >= 0xF00000 && addr < 0xFC0000 && this.cgrom) {
      const offset = addr - 0xF00000;
      if (offset < this.cgrom.length) {
        return this.cgrom[offset];
      }
    }

    return 0xFF;
  }

  write8(addr, value) {
    addr &= 0xFFFFFF;
if (addr >= 0xC00000 && addr < 0xE00000) {
      const offset = addr - 0xC00000;
      const plane = (offset >> 17) & 3;
      this.gvr[plane][offset & 0x1FFFF] = value;
      return;
    }
    // RAM領域のみ書き込み可能
    if (addr < 0x200000) {
      this.ram[addr] = value & 0xFF;
    }
  }

  // 16bit読み込み
  read16(addr) {
    return (this.read8(addr) << 8) | this.read8(addr + 1);
  }

  // 32bit読み込み
  read32(addr) {
    return (this.read16(addr) << 16) | this.read16(addr + 2);
  }

}
class CRTC {
  constructor() {
    this.hRes = 512;
    this.vRes = 512;
    this.displayEnable = true;
  }
}

/* =========================
   Video Subsystem
========================= */


/* =========================
   Sound Subsystem (Stub)
========================= */
class VideoSubsystem {
  constructor(canvas, system) {
    this.sys = system;
    this.ctx = canvas.getContext("2d");
    this.image = this.ctx.createImageData(512, 512);
  }
reset() {
    this.clear();
  }
  clear() {
    this.image.data.fill(0);
  }
renderTextLayer(data) {
  const mem = this.sys.memory;

  const cols = 64; // 512 / 8
  const rows = 64;

  for (let ty = 0; ty < rows; ty++) {
    for (let tx = 0; tx < cols; tx++) {

      const t = mem.tram[ty * 1024 + tx];
      const charCode = (t >> 8) & 0xFF;
      const color = t & 0x0F;

      if (charCode === 0) continue;

      for (let cy = 0; cy < 8; cy++) {


        const bits = mem.getFontBitmap(charCode, cy);


        for (let cx = 0; cx < 8; cx++) {
          if ((bits & (0x80 >> cx)) === 0) continue;

          const px = tx * 8 + cx;
          const py = ty * 8 + cy;
          const p  = (py * 512 + px) * 4;

          const rgb = mem.palette[color];
          data[p + 0] = ((rgb >> 8) & 0xF) * 17;
          data[p + 1] = ((rgb >> 4) & 0xF) * 17;
          data[p + 2] = (rgb & 0xF) * 17;
          data[p + 3] = 255;
        }
      }
    }
  }
}

  render() {
    const mem = this.sys.memory;
    const pal = mem.palette;
    const data = this.image.data;

    let ptr = 0;
    for (let y = 0; y < 512; y++) {
      for (let x = 0; x < 512; x++) {

        // VRAM address (1byte = 8px 横方向)
        const addr = (y * 512 + x) >> 3;
        const bit = 7 - (x & 7);

        let color =
          ((mem.gvr[0][addr] >> bit) & 1) |
          (((mem.gvr[1][addr] >> bit) & 1) << 1) |
          (((mem.gvr[2][addr] >> bit) & 1) << 2) |
          (((mem.gvr[3][addr] >> bit) & 1) << 3);

        const rgb = pal[color];
        data[ptr++] = ((rgb >> 8) & 0xF) * 17;
        data[ptr++] = ((rgb >> 4) & 0xF) * 17;
        data[ptr++] = (rgb & 0xF) * 17;
        data[ptr++] = 255;
      }
    }
this.renderTextLayer(data);
    this.ctx.putImageData(this.image, 0, 0);
  }
}
class SoundSubsystem {
  reset() {}
}
function drawTextTest(x68k) {
  const mem = x68k.memory;
  mem.tram.fill(0);

  const text = "HELLO X68000";
  for (let i = 0; i < text.length; i++) {
    const ascii = text.charCodeAt(i);

    // ★ 変換しない
//mem.tram[0] = (0x41 << 8) | 0x04; // 'A'

    mem.tram[i] = (ascii << 8) | 0x04; // 白
  }
}


function asciiToX68kFont(code) {
  // 数字 0–9
  if (code >= 0x30 && code <= 0x39) {
    return 0x10 + (code - 0x30);
  }

  // 英大文字 A–Z
  if (code >= 0x41 && code <= 0x5A) {
    return 0x20 + (code - 0x41);
  }

  // 英小文字 a–z
  if (code >= 0x61 && code <= 0x7A) {
    return 0x40 + (code - 0x61);
  }

  // スペース
  if (code === 0x20) return 0x00;

  return 0x00;
}

/* =========================
   Input Subsystem
========================= */
class InputSubsystem {
  constructor() {
    this.keys = {};
    window.addEventListener("keydown", e => this.keys[e.code] = true);
    window.addEventListener("keyup", e => this.keys[e.code] = false);
  }
}

/* =========================
   UI Wiring
========================= */
const canvas = document.getElementById("screen");
const status = document.getElementById("status");
const pcView = document.getElementById("pc");
const startBtn = document.getElementById("start");
const x68k = new X68000(canvas);
let iplLoaded = false;
let cgLoaded = false;

// IPLROM読み込み
document.getElementById("iplrom").addEventListener("change", e => {
  const file = e.target.files[0];
  if (!file) return;

  document.getElementById("ipl-name").textContent = `✓ ${file.name}`;

  const reader = new FileReader();
  reader.onload = () => {
    x68k.memory.loadIPLROM(reader.result);
    iplLoaded = true;
    updateStatus();
  };
  reader.readAsArrayBuffer(file);
});

// CGROM読み込み
document.getElementById("cgrom").addEventListener("change", e => {
  const file = e.target.files[0];
  if (!file) return;

  document.getElementById("cg-name").textContent = `✓ ${file.name}`;

  const reader = new FileReader();
  reader.onload = () => {
    x68k.memory.loadCGROM(reader.result);
    cgLoaded = true;
    updateStatus();
  };
  reader.readAsArrayBuffer(file);
});

document.getElementById("rom").addEventListener("change", e => {
  const file = e.target.files[0];
  if (!file) return;

  document.getElementById("file-name").textContent = file.name;

  const reader = new FileReader();
  reader.onload = () => {
    x68k.loadROM(reader.result);
    status.textContent = "ROM Loaded";
  };
  reader.readAsArrayBuffer(file);
});

function updateStatus() {
  if (iplLoaded && cgLoaded) {
    status.textContent = "ROMs Loaded - Ready";
    startBtn.disabled = false;
  } else if (iplLoaded) {
    status.textContent = "IPL ROM Loaded - Need CG ROM";
  } else if (cgLoaded) {
    status.textContent = "CG ROM Loaded - Need IPL ROM";
  }
}

startBtn.addEventListener("click", () => {
  if (!iplLoaded || !cgLoaded) {
    alert("Please load both IPL ROM and CG ROM first");
    return;
  }
  
  x68k.reset();

x68k.memory.palette[0] = 0x000;
x68k.memory.palette[4] = 0xFFF;

  x68k.start();
console.log(x68k.memory.cgrom.length);

drawTextTest(x68k);
  status.textContent = "Running";
});


setInterval(() => {
  pcView.textContent = "0x" + x68k.cpu.pc.toString(16).padStart(6, "0");
}, 100);

</script>



  </body>
</html>