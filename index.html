<!DOCTYPE html>
<html lang="ja">
  <head>
    <meta charset="utf-8" />
    <title>X68000</title>
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <link rel="icon" href="nes.png" type="image/png">
    <style>
       :root {
        color-scheme: light dark;
      }
      @font-face {
  font-family: "Renner";
  src: url("./Renner.ttf") format("truetype");
  font-display: swap;
 
}
      body {
        background:rgb(0, 0, 0);
       font-family: "Renner", sans-serif;
        margin: 0;
        padding:0;
      }
h1{
font-weight:300;
font-size:25px;
}
      header {
        display: flex;
        gap: 12px;
        align-items: center;
        margin-bottom: 12px;
      }
      canvas{
        
        height: 100%;              /* コンテナ幅に合わせる */
      aspect-ratio: 256 / 240;  /* 内部解像度の比率を維持 */
        image-rendering: pixelated;
        border: 1px solid #000000;
        background: #000;
      }
      .row {
        padding-top:0px;
height:83vh;
justify-content: center; 
        display: flex;
        gap: 12px;
        align-items: center;
      }
      .mono {
       font-size:20px; 
      }
      small {
        opacity: 0.7;
      }
      
button{
font-family: "Renner", sans-serif;
padding:10px;
background:rgb(0, 0, 0);
color:rgb(255, 255, 255);
border:1px solid rgb(255, 255, 255);
}
.file-input {
  display: none; /* 本体は隠す */
}

.file-label {
  display: inline-block;
  padding: 10px 16px;
  background: #000000;
  color: white;
    border:1px solid white;
  border-radius: 0px;
  cursor: pointer;
  font-size: 14px;
  transition: background 0.2s;
}



    </style>
  </head>
  <body>
   
    <header>
<h1>X68000</h1>
      
<label class="file-label">
  Select
  <input id="rom" type="file" class="file-input">
</label>
<span id="file-name"></span>

      
      <button id="fullscreenBtn">Fullscreen</button>

      <button id="start">Start</button>
      <div class="mono" id="status">No ROM</div>
      <label class="file-label">
    IPL ROM
    <input id="iplrom" type="file" class="file-input">
  </label>
  <span id="ipl-name" class="file-status"></span>

  <label class="file-label">
    CG ROM
    <input id="cgrom" type="file" class="file-input">
  </label>
  <span id="cg-name" class="file-status"></span>
  
      <div><span class="mono">CPU PC:</span> <span id="pc" class="mono">0x0000</span></div>
    </header>
    <div class="row">
      <canvas id="screen" width="256" height="240"></canvas>
      <div style="display:none">
        <div><b>FPS:</b> <span id="fps">0</span></div>
        <div><b>CPU PC:</b> <span id="pc" class="mono">0x0000</span></div>
        <div><b>Cycles:</b> <span id="cyc" class="mono">0</span></div>
        <div><b>VRAM V:</b><span id="pcp" class="mono">0x0000</span></div>
        <div><b>VRAM T:</b><span id="ppx" class="mono">0x0000</span></div>
        <div><b>CPU S:</b><span id="ram" class="mono">0x0000</span></div>
        <div><b>CPU P:</b><span id="mapper" class="mono">0x0000</span></div>

        
      </div>
    </div>

    

    <script type="module">

/* =========================
   X68000 Core
========================= */
class X68000 {
  constructor(canvas) {
    this.cpu = new MC68000(this);
    this.memory = new MemoryMap();
    this.video = new VideoSubsystem(canvas);
    this.sound = new SoundSubsystem();
    this.input = new InputSubsystem();

    this.running = false;
    this.lastTime = 0;
  }

  reset() {
    this.memory.reset();
    this.cpu.reset();
    this.video.reset();
    this.sound.reset();
    this.running = false;
  }

  loadROM(buffer) {
    this.memory.loadROM(buffer);
  }

  start() {
    this.running = true;
    requestAnimationFrame(this.loop.bind(this));
  }

  loop(time) {
    if (!this.running) return;

    const delta = time - this.lastTime;
    this.lastTime = time;

    // 1フレーム分実行（仮）
    this.stepFrame();

    this.video.render();

    requestAnimationFrame(this.loop.bind(this));
  }

  stepFrame() {
    const CYCLES_PER_FRAME = 100000; // 仮

    let cycles = 0;
    while (cycles < CYCLES_PER_FRAME) {
      cycles += this.cpu.step();
    }
  }
}

/* =========================
   MC68000 CPU (Stub)
========================= */
class MC68000 {
  constructor(system) {
    this.system = system;
    this.d = new Uint32Array(8);  // データレジスタ D0-D7
    this.a = new Uint32Array(8);  // アドレスレジスタ A0-A7
    this.pc = 0;                  // プログラムカウンタ
    this.sr = 0x2700;             // ステータスレジスタ
    this.cycles = 0;
  }

  reset() {
    // 初期スタックポインタとPCを取得
    const mem = this.system.memory;
    this.a[7] = (mem.read8(0) << 24) | (mem.read8(1) << 16) | 
                (mem.read8(2) << 8) | mem.read8(3);
    this.pc = (mem.read8(4) << 24) | (mem.read8(5) << 16) | 
              (mem.read8(6) << 8) | mem.read8(7);
    
    this.d.fill(0);
    this.a.fill(0);
    this.a[7] = this.a[7] || 0x100000;
    this.sr = 0x2700;
    this.cycles = 0;
  }
readWord() {
    const val = (this.system.memory.read8(this.pc) << 8) | 
                 this.system.memory.read8(this.pc + 1);
    this.pc += 2;
    return val;
  }

  readLong() {
    const high = this.readWord();
    const low = this.readWord();
    return (high << 16) | low;
  }
  step() {
    const opcode = this.readWord();
    
    // 命令デコード
    const decoded = this.decode(opcode);
    if (decoded) {
      decoded();
    }
    
    return 4; // 仮のサイクル数
  }

  decode(opcode) {
    // MOVE命令 (00xx, 01xx, 10xx, 11xx)
    if ((opcode & 0xC000) !== 0) {
      const size = (opcode >> 12) & 3;
      if (size === 1 || size === 3 || size === 2) {
        return () => this.execMove(opcode, size);
      }
    }

    // NOP (0x4E71)
    if (opcode === 0x4E71) {
      return () => {};
    }

    // RTS (0x4E75)
    if (opcode === 0x4E75) {
      return () => this.execRTS();
    }

    // JSR (0x4E8x, 0x4EAx, 0x4EBx)
    if ((opcode & 0xFFC0) === 0x4E80) {
      return () => this.execJSR(opcode);
    }

    // MOVEQ (0x7xxx)
    if ((opcode & 0xF100) === 0x7000) {
      return () => this.execMOVEQ(opcode);
    }

    // ADD/SUB (0xDxxx / 0x9xxx)
    if ((opcode & 0xF000) === 0xD000) {
      return () => this.execADD(opcode);
    }
    if ((opcode & 0xF000) === 0x9000) {
      return () => this.execSUB(opcode);
    }

    // CMP (0xBxxx)
    if ((opcode & 0xF000) === 0xB000) {
      return () => this.execCMP(opcode);
    }

    // Bcc (0x6xxx)
    if ((opcode & 0xF000) === 0x6000) {
      return () => this.execBcc(opcode);
    }

    // 未実装命令
    //console.warn(`Unknown opcode: 0x${opcode.toString(16).padStart(4, '0')} at PC: 0x${(this.pc-2).toString(16)}`);
    return () => {};
  }

  // MOVEQ - クイックムーブ
  execMOVEQ(opcode) {
    const reg = (opcode >> 9) & 7;
    let data = opcode & 0xFF;
    // 符号拡張
    if (data & 0x80) data |= 0xFFFFFF00;
    this.d[reg] = data >>> 0;
    this.updateFlags(data, 4);
  }

  // MOVE命令
  execMove(opcode, sizeCode) {
    const size = sizeCode === 1 ? 1 : sizeCode === 3 ? 2 : 4;
    const dstReg = (opcode >> 9) & 7;
    const dstMode = (opcode >> 6) & 7;
    const srcMode = (opcode >> 3) & 7;
    const srcReg = opcode & 7;

    const src = this.getEA(srcMode, srcReg, size);
    this.setEA(dstMode, dstReg, size, src);
    this.updateFlags(src, size);
  }

  // ADD命令
  execADD(opcode) {
    const reg = (opcode >> 9) & 7;
    const mode = (opcode >> 3) & 7;
    const ereg = opcode & 7;
    
    const src = this.getEA(mode, ereg, 4);
    const dst = this.d[reg];
    const result = (dst + src) >>> 0;
    
    this.d[reg] = result;
    this.updateFlags(result, 4);
  }

  // SUB命令
  execSUB(opcode) {
    const reg = (opcode >> 9) & 7;
    const mode = (opcode >> 3) & 7;
    const ereg = opcode & 7;
    
    const src = this.getEA(mode, ereg, 4);
    const dst = this.d[reg];
    const result = (dst - src) >>> 0;
    
    this.d[reg] = result;
    this.updateFlags(result, 4);
  }

  // CMP命令
  execCMP(opcode) {
    const reg = (opcode >> 9) & 7;
    const mode = (opcode >> 3) & 7;
    const ereg = opcode & 7;
    
    const src = this.getEA(mode, ereg, 4);
    const dst = this.d[reg];
    const result = (dst - src) >>> 0;
    
    this.updateFlags(result, 4);
  }

  // 分岐命令
  execBcc(opcode) {
    const cond = (opcode >> 8) & 0xF;
    let disp = opcode & 0xFF;
    
    if (disp === 0) {
      disp = this.readWord();
      if (disp & 0x8000) disp |= 0xFFFF0000;
    } else if (disp & 0x80) {
      disp |= 0xFFFFFF00;
    }

    if (this.testCondition(cond)) {
      this.pc = (this.pc + disp) >>> 0;
    }
  }

  // JSR - サブルーチンジャンプ
  execJSR(opcode) {
    const mode = (opcode >> 3) & 7;
    const reg = opcode & 7;
    
    const addr = this.getEA(mode, reg, 4);
    this.push32(this.pc);
    this.pc = addr;
  }

  // RTS - リターン
  execRTS() {
    this.pc = this.pop32();
  }

  // 実効アドレス取得
  getEA(mode, reg, size) {
    switch(mode) {
      case 0: // Dn
        return this.d[reg] & this.mask(size);
      case 1: // An
        return this.a[reg] & this.mask(size);
      case 7:
        if (reg === 4) { // immediate
          return size === 4 ? this.readLong() : this.readWord();
        }
        break;
    }
    return 0;
  }

  setEA(mode, reg, size, value) {
    switch(mode) {
      case 0: // Dn
        this.d[reg] = value & this.mask(size);
        break;
      case 1: // An
        this.a[reg] = value & this.mask(size);
        break;
    }
  }

  mask(size) {
    return size === 1 ? 0xFF : size === 2 ? 0xFFFF : 0xFFFFFFFF;
  }

  // フラグ更新
  updateFlags(result, size) {
    const mask = this.mask(size);
    result &= mask;
    
    this.sr &= 0xFFF0; // N,Z,V,C をクリア
    
    if (result === 0) this.sr |= 0x04; // Z
    if (size === 4 && (result & 0x80000000)) this.sr |= 0x08; // N
    if (size === 2 && (result & 0x8000)) this.sr |= 0x08;
    if (size === 1 && (result & 0x80)) this.sr |= 0x08;
  }

  testCondition(cond) {
    const z = (this.sr & 0x04) !== 0;
    const n = (this.sr & 0x08) !== 0;
    const c = (this.sr & 0x01) !== 0;
    const v = (this.sr & 0x02) !== 0;

    switch(cond) {
      case 0x0: return true;          // BRA
      case 0x1: return false;         // BSR
      case 0x4: return !c;            // BCC
      case 0x5: return c;             // BCS
      case 0x6: return !z;            // BNE
      case 0x7: return z;             // BEQ
      default: return false;
    }
  }

  push32(value) {
    this.a[7] -= 4;
    const addr = this.a[7];
    this.system.memory.write8(addr, (value >> 24) & 0xFF);
    this.system.memory.write8(addr + 1, (value >> 16) & 0xFF);
    this.system.memory.write8(addr + 2, (value >> 8) & 0xFF);
    this.system.memory.write8(addr + 3, value & 0xFF);
  }

  pop32() {
    const addr = this.a[7];
    const value = (this.system.memory.read8(addr) << 24) |
                  (this.system.memory.read8(addr + 1) << 16) |
                  (this.system.memory.read8(addr + 2) << 8) |
                  this.system.memory.read8(addr + 3);
    this.a[7] += 4;
    return value >>> 0;
  }
}

/* =========================
   Memory Map
========================= */
class MemoryMap {
  constructor() {
    this.ram = new Uint8Array(0x200000); // 2MB RAM
    this.rom = null;
    this.iplrom = null;                       // IPL ROM
    this.cgrom = null;  
  }

  reset() {
    this.ram.fill(0);
  }

  loadROM(buffer) {
    this.rom = new Uint8Array(buffer);
  }
loadIPLROM(buffer) {
    this.iplrom = new Uint8Array(buffer);
    console.log(`IPL ROM loaded: ${this.iplrom.length} bytes`);
  }

  loadCGROM(buffer) {
    this.cgrom = new Uint8Array(buffer);
    console.log(`CG ROM loaded: ${this.cgrom.length} bytes`);
  }

  read8(addr) {
    addr &= 0xFFFFFF; // 24bitアドレス

    // IPL ROM: 0x000000-0x0BFFFF (768KB) または 0x0FFFFF (1MB)
    if (addr < 0x100000 && this.iplrom && addr < this.iplrom.length) {
      return this.iplrom[addr];
    }
    
    // RAM: 0x000000-0x1FFFFF (メインRAM)
    // ※実際はIPL ROMとRAMは排他的だが、簡易実装
    if (addr < 0x200000) {
      return this.ram[addr];
    }

    // CG ROM: 0xF00000-0xFBFFFF (768KB)
    if (addr >= 0xF00000 && addr < 0xFC0000 && this.cgrom) {
      const offset = addr - 0xF00000;
      if (offset < this.cgrom.length) {
        return this.cgrom[offset];
      }
    }

    return 0xFF;
  }

  write8(addr, value) {
    addr &= 0xFFFFFF;

    // RAM領域のみ書き込み可能
    if (addr < 0x200000) {
      this.ram[addr] = value & 0xFF;
    }
  }

  // 16bit読み込み
  read16(addr) {
    return (this.read8(addr) << 8) | this.read8(addr + 1);
  }

  // 32bit読み込み
  read32(addr) {
    return (this.read16(addr) << 16) | this.read16(addr + 2);
  }

}

/* =========================
   Video Subsystem
========================= */
class VideoSubsystem {
  constructor(canvas) {
    this.ctx = canvas.getContext("2d");
    this.width = 256;
    this.height = 240;
    this.image = this.ctx.createImageData(this.width, this.height);
  }

  reset() {
    this.clear();
  }

  clear() {
    this.image.data.fill(0);
  }

  render() {
    // 仮：黒画面
    this.ctx.putImageData(this.image, 0, 0);
  }
}

/* =========================
   Sound Subsystem (Stub)
========================= */
class SoundSubsystem {
  reset() {}
}

/* =========================
   Input Subsystem
========================= */
class InputSubsystem {
  constructor() {
    this.keys = {};
    window.addEventListener("keydown", e => this.keys[e.code] = true);
    window.addEventListener("keyup", e => this.keys[e.code] = false);
  }
}

/* =========================
   UI Wiring
========================= */
const canvas = document.getElementById("screen");
const status = document.getElementById("status");
const pcView = document.getElementById("pc");
const startBtn = document.getElementById("start");
const x68k = new X68000(canvas);
let iplLoaded = false;
let cgLoaded = false;

// IPLROM読み込み
document.getElementById("iplrom").addEventListener("change", e => {
  const file = e.target.files[0];
  if (!file) return;

  document.getElementById("ipl-name").textContent = `✓ ${file.name}`;

  const reader = new FileReader();
  reader.onload = () => {
    x68k.memory.loadIPLROM(reader.result);
    iplLoaded = true;
    updateStatus();
  };
  reader.readAsArrayBuffer(file);
});

// CGROM読み込み
document.getElementById("cgrom").addEventListener("change", e => {
  const file = e.target.files[0];
  if (!file) return;

  document.getElementById("cg-name").textContent = `✓ ${file.name}`;

  const reader = new FileReader();
  reader.onload = () => {
    x68k.memory.loadCGROM(reader.result);
    cgLoaded = true;
    updateStatus();
  };
  reader.readAsArrayBuffer(file);
});

document.getElementById("rom").addEventListener("change", e => {
  const file = e.target.files[0];
  if (!file) return;

  document.getElementById("file-name").textContent = file.name;

  const reader = new FileReader();
  reader.onload = () => {
    x68k.loadROM(reader.result);
    status.textContent = "ROM Loaded";
  };
  reader.readAsArrayBuffer(file);
});

function updateStatus() {
  if (iplLoaded && cgLoaded) {
    status.textContent = "ROMs Loaded - Ready";
    startBtn.disabled = false;
  } else if (iplLoaded) {
    status.textContent = "IPL ROM Loaded - Need CG ROM";
  } else if (cgLoaded) {
    status.textContent = "CG ROM Loaded - Need IPL ROM";
  }
}

startBtn.addEventListener("click", () => {
  if (!iplLoaded || !cgLoaded) {
    alert("Please load both IPL ROM and CG ROM first");
    return;
  }
  
  x68k.reset();
  x68k.start();
  status.textContent = "Running";
});


setInterval(() => {
  pcView.textContent = "0x" + x68k.cpu.pc.toString(16).padStart(6, "0");
}, 100);

</script>



  </body>
</html>